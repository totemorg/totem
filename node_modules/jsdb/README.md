# JSDB

Provides mysql and neo4j agnosticators, a task regulator, and various data stashing and 
ingesting methods.

## mysql

A mysql DB can be accessed using a traditional query, by setting a multiple or single dataset context:

	const { sqlThread } = JSDB = require("jsdb");
	
	sqlThread( sql => {
	
		// traditional query connector
		sql.query( "...", [ ... ], (err,info) => {
		});
		
		// multiple dataset context
		sql.context( {ds1:ATTRIBUTES, ds2:ATTRIBUTES, ... }, function (ctx) {

			const ds1 = ctx.ds1, ds2 = ctx.ds2, ...;

		});
		
		// single dataset context
		const ds = new JSDB.DS(sql, ATTRIBUTES);
		
	});

where dsN are datasets, sql in a MySQL connector, and dataset ATTRIBUTES = {key:value, ... } are 
described below. 

Using the JS-agnosticator, the following queries can then be performed:

	ds.rec = { FIELD:VALUE, ... }		// update matched record(s) 
	ds.rec = [ {...}, {...}, ... ]		// insert record(s)
	ds.rec = null 		// delete matched record(s)
	ds.rec = function CB(recs,me) {...}			// select matched record(s)

with callback to a response CB method when the query completes.  Alternatively,
queries can be issued like this:

	ds.res = callback() { ... }
	ds.data = [ ... ]
	ds.rec = CRUDE

or in record-locked mode using:

	ds.rec = "lock." + CRUDE

where CRUDE = "select" | "delete" | "update" | "insert" | "execute".

Dataset ATTRIBUTES = { key: value, ... } provide SQL agnostication:

	table: 	DB.TABLE || TABLE
	where: 	[ FIELD, FIELD, ... ] | { CLAUSE:null, nlp:PATTERN, bin:PATTERN, qex:PATTERN, has:PATTERN, like:PATTERN, FIELD:VALUE, FIELD:[MIN,MAX], ...} | CLAUSE
	res: 	function CB(ds) {...}
	having: [ FIELD, VALUE ] | [ FIELD, MIN, MAX ] | {FIELD:VALUE, CLAUSE:null, FIELD:[MIN,MAX], ...} | CLAUSE
	order: 	[ {FIELD:ORDER, ...}, {property:FIELD, direction:ORDER}, FIELD, ...] | "FIELD, ..."
	group: 	[ FIELD, ...] | "FIELD, ..."
	limit: 	[ START, COUNT ] | {start:START, count:COUNT} | "START,COUNT"
	index:	[ FIELD, ... ] | "FIELD, ... " | { has:PATTERN, nlp:PATTERN, bin:PATTERN, qex:PATTERN, browse:"FIELD,...", pivot: "FIELD,..." }

In addition, update journalling, search tracking, query broadcasting, and auto field conversion is 
supported using these ATTRIBUTES:

	unsafeok: 	[true] | false 		// allow potentially unsafe queries
	trace: [true] | false			// trace queries
	journal: true | [false] 		// enable table journalling
	search: "field,field,..." 		// define fulltext search fields
	track: true | [false] 		// enable search tracking
	ag: "..." 		// aggregate where/having with least(?,1), greatest(?,0), sum(?), ...

The select query will callback the CB = [each || all || clone || trace] handler with each/all record(s) matched 
by .where, indexed by  .index, ordered by .order ordering, grouped by .group, filtered by .having 
and limited by .limit ATTRIBUTES.  Select will search for PATTERN 
using its index.nlp (natural language parse), index.bin (binary mode), index.qex (query expansion), 
or group recording according to its index.browse (file navigation) or index.pivot (joint statistics).

Non-select queries will broadcast a change to all clients if a where.ID is presented (and an emiitter
was configured), and will journal the change when jounalling is enabled.

## neo4j

**JSDB** also provides a cypher connector to the neo4j database:

	const {neoThread, cyper} = JSDB = require("jsdb");
	
	neoThread( neo => {	
		neo.cypher( "...", [ ... ], (err,recs) => {
		});
	});

## Task regulation

In addition, **JSDB** provides a task/job queueing regulator:

## Data stashing

## Data ingesting

## Usage

**JSDB** is configured and started like this:

	const {sqlThread, neoThread} = JSDB = require("jsdb");
	
	JSDB.config({ 
	
		dbtx: {		// table translator
			X: "DB.Y", ...
		},
		
		emit:  (crude,parms) => {  // method to bradcast changes to other socket.io clients
		}, 
		
		mysql : {	// 	database connection parms
			host: ...
			user: ...
			pass: ...
		}

	});

where [its configuration keys](http://totem.zapto.org/shares/prm/jsdb/index.html) || [COE](https://totem.west.ile.nga.ic.gov/shares/prm/jsdb/index.html) || [SBU](https://totem.nga.mil/shares/prm/jsdb/index.html)
follow the [ENUM deep copy conventions](https://github.com/totemstan/enum) || [COE](https://sc.appdev.proj.coe/acmesds/enum) || [SBU](https://gitlab.west.nga.ic.gov/acmesds/enum).

### Create dataset on a new sql thread

	sqlThread( sql => {
	
		var ds = new JSDB.DS(sql,{
			table:"test.x", 
			rec: (recs) => console.log(recs) 
		});
		
	});
### Create dataset and access each record

	var ds = new JSDB.DS(sql,{
		table:"test.x",
		limit:[0,1],
		rec: function each(rec) {console.log(rec)}
	});
		
	var ds = new JSDB.DS(sql,{
		table:"test.x",
		trace:1,
		where:{ x: "x=12" },
		rec: function each(rec) {console.log(rec)}});
		
	var ds = new JSDB.DS(sql,{
		table:"test.x",
		trace:1,
		where:{ a: "a = 0.5"},
		rec: function each(rec) {console.log(rec)}
	});
	
	var ds = new JSDB.DS(sql,{
		table:"test.x",
		trace:1,
		where:{ a: "a<30"},
		rec: function each(rec) {console.log(rec)}
	});
### Create dataset and access all records

	var ds = new JSDB.DS(sql,{
		table:"test.x",
		trace:1,
		where:{
			a: "a<30", 
			b: "b!=0",
			x: "x like '%find%'",
			ID: "ID=5"},
		rec: (recs) => console.log(recs)
	});
	
	var ds = new JSDB.DS(sql,{
		table:"test.x",
		trace:1,
		order:[{property:"a",direction:"asc"}],
		rec: (recs) => console.log(recs)
	});
	
	var ds = new JSDB.DS(sql,{
		table:"test.x",
		trace:1,
		index:{pivot:"root"},
		group:"a,b",
		rec: (recs) => console.log(recs)
	});
### Select ds record(s) matched by ds.where

	ds.where = {ID: "ID=1"};
	ds.rec = (rec) => console.log(rec);
### Delete ds record(s) matched by ds.where

	ds.where = {ID:"ID=2"}
	ds.rec = null
### Update ds record(s) matched by ds.where

	ds.where = null
	ds.rec = [{a:1,b:2,ds:"hello"},{a:10,b:20,x:"there"}]
	ds.where = {ID: "ID=3"}
	ds.rec = {a:100} 
	
## Installation

Clone [**JSDB** database agnosticator](https://github.com/totemstan/jsdb) || [COE](https://sc.appdev.proj.coe/acmesds/jsdb) || [SBU](https://gitlab.west.nga.ic.gov/acmesds/jsdb) into your PROJECT folder.  

## Requires

[ENUM standard enumerators](https://github.com/totemstan/enum) || [COE](https://sc.appdev.proj.coe/acmesds/enum) || [SBU](https://gitlab.west.nga.ic.gov/acmesds/enum).  

MySQL databases:

	+ openv.hawks Queried for moderaters when journalling a dataset.
	+ openv.journal	Updated with changes when journalling enabled.
	+ openv.locks Updated when record locks used (e.g. using forms).
	+ openv.files Databrick files when saving stashes
	+ openv._stats Databrick stats when saving stashes
	+ openv.events For storing event data during saving stashes
	+ openv.profile Client information to manage task queues
	+ openv.queues Task queues managed by regulator
	+ openv.cache Place to cache data

## Manage 

	npm test [ ? || B1 || B2 || ... ]	# unit test
	npm run [ edit || start ]			# Configure environment
	npm run [ prmprep || prmload ]		# Revise PRM

## Contacting, Contributing, Following

Feel free to [submit and status TOTEM issues](http://totem.zapto.org/issues.view) || [COE](https://totem.west.ile.nga.ic.gov/issues.view) || [SBU](https://totem.nga.mil/issues.view), [contribute TOTEM notebooks](http://totem.zapto.org/shares/notebooks/) || [COE](https://totem.west.ile.nga.ic.gov/shares/notebooks/) || [SBU](https://totem.nga.mil/shares/notebooks/),
[inspect TOTEM requirements](http://totem.zapto.org/reqts.view) || [COE](https://totem.west.ile.nga.ic.gov/reqts.view) || [SBU](https://totem.nga.mil/reqts.view), [browse TOTEM holdings](http://totem.zapto.org/) || [COE](https://totem.west.ile.nga.ic.gov/) || [SBU](https://totem.nga.mil/), 
or [follow TOTEM milestones](http://totem.zapto.org/milestones.view) || [COE](https://totem.west.ile.nga.ic.gov/milestones.view) || [SBU](https://totem.nga.mil/milestones.view).

## License

[MIT](LICENSE)


<a name="module_JSDB"></a>

## JSDB
Provides mysql and neo4j agnosticators as well as a task queuer.

**Requires**: <code>module:cluster</code>, <code>module:mysql</code>, <code>module:os</code>, <code>module:neo4j-driver</code>, <code>module:fs</code>, <code>module:enums</code>  

* [JSDB](#module_JSDB)
    * _static_
        * [.dsAttrs](#module_JSDB.dsAttrs)
        * [.savers](#module_JSDB.savers)
        * [.dropCard](#module_JSDB.dropCard)
        * [.wildMatch](#module_JSDB.wildMatch)
        * [.queues](#module_JSDB.queues)
        * [.errors](#module_JSDB.errors)
        * [.attrs](#module_JSDB.attrs)
        * [.mysqlOpts](#module_JSDB.mysqlOpts)
        * [.config()](#module_JSDB.config)
    * _inner_
        * [~cache()](#module_JSDB..cache)
        * [~flattenCatalog
	Flatten entire database for searching the catalog

	Need to rework using serialize()](#module_JSDB..flattenCatalog
	Flatten entire database for searching the catalog

	Need to rework using serialize)
        * [~ingestFile(path, opts, cb)](#module_JSDB..ingestFile)
        * [~serialize()](#module_JSDB..serialize)
        * [~saveContext()](#module_JSDB..saveContext)
            * [~saveEvents(sql, evs, ctx, cb)](#module_JSDB..saveContext..saveEvents)
                * [~stashify(evs, watchKey, targetPrefix, ctx, stash, cb)](#module_JSDB..saveContext..saveEvents..stashify)
        * [~queueTask()](#module_JSDB..queueTask)

<a name="module_JSDB.dsAttrs"></a>

### JSDB.dsAttrs
Reserved for dataset attributes

**Kind**: static property of [<code>JSDB</code>](#module_JSDB)  
**Cfg**: <code>Object</code>  
<a name="module_JSDB.savers"></a>

### JSDB.savers
**Kind**: static property of [<code>JSDB</code>](#module_JSDB)  
**Cfg**: <code>Object</code>  
<a name="module_JSDB.dropCard"></a>

### JSDB.dropCard
**Kind**: static property of [<code>JSDB</code>](#module_JSDB)  
**Cfg**: <code>Object</code>  
<a name="module_JSDB.wildMatch"></a>

### JSDB.wildMatch
**Kind**: static property of [<code>JSDB</code>](#module_JSDB)  
**Cfg**: <code>Object</code>  
<a name="module_JSDB.queues"></a>

### JSDB.queues
**Kind**: static property of [<code>JSDB</code>](#module_JSDB)  
**Cfg**: <code>Object</code>  
<a name="module_JSDB.errors"></a>

### JSDB.errors
**Kind**: static property of [<code>JSDB</code>](#module_JSDB)  
**Cfg**: <code>Object</code>  
<a name="module_JSDB.attrs"></a>

### JSDB.attrs
**Kind**: static property of [<code>JSDB</code>](#module_JSDB)  
**Cfg**: <code>Object</code>  
<a name="module_JSDB.mysqlOpts"></a>

### JSDB.mysqlOpts
MySQL connection options or null to disable

**Kind**: static property of [<code>JSDB</code>](#module_JSDB)  
**Cfg**: <code>Object</code>  
<a name="module_JSDB.config"></a>

### JSDB.config()
**Kind**: static method of [<code>JSDB</code>](#module_JSDB)  
**Cfg**: <code>Object</code>  
<a name="module_JSDB..cache"></a>

### JSDB~cache()
Implements generic cache.  Looks for cache given opts.key and, if found, returns cached results on cb(results);
	otherwse, if not found, returns results via opts.make(probeSite, opts.parms, cb).  If cacheing fails, then opts.default 
	is returned.  The returned results will always contain a results.ID for its cached ID.  If a opts.default is not provided,
	then the cb callback in not made.

**Kind**: inner method of [<code>JSDB</code>](#module_JSDB)  
<a name="module_JSDB..flattenCatalog
	Flatten entire database for searching the catalog

	Need to rework using serialize"></a>

### JSDB~flattenCatalog
	Flatten entire database for searching the catalog

	Need to rework using serialize()
**Kind**: inner method of [<code>JSDB</code>](#module_JSDB)  
<a name="module_JSDB..ingestFile"></a>

### JSDB~ingestFile(path, opts, cb)
ingest a comma-delimited, column-headered stream at path using the supplied
	streaming options.  Records are inserted into the sql target table defined 
	by the path = /.../target.type.  The keys="recKey:asKey sqlType,..." defines
	how record values are stored.

**Kind**: inner method of [<code>JSDB</code>](#module_JSDB)  

| Param | Type | Description |
| --- | --- | --- |
| path | <code>String</code> | source file |
| opts | <code>Object</code> | {keys,comma,newline,limit,as,batch} streaming options |
| cb | <code>function</code> | Callback([record,...]) |

<a name="module_JSDB..serialize"></a>

### JSDB~serialize()
Serialize a select query.

	sql.serialize({
		ds1: "SELECT ... ",
		ds2: "SELECT ... ", ...
		ds3: "/dataset?...", 
		ds4: "/dataset?...", ...
	}, ctx, ctx => {
		// ctx[ ds1 || ds2 || ... ] records
	});

**Kind**: inner method of [<code>JSDB</code>](#module_JSDB)  
<a name="module_JSDB..saveContext"></a>

### JSDB~saveContext()
Aggregate and save events evs = [ev, ...] || { } under direction of the 
	supplied context ctx = { Save: { ... }, Ingest: true||false, Export: true||false,
	... }.  Stashify is used to 
	aggreagate data using [ev, ...].stashify( "at", "Save_", ctx ) where events ev = 
	{ at: KEY, A: a1, B: b1, ... } || { x: x1, y: y1 } are saved in Save_KEY = 
	{A: [a1, a2,  ...], B: [b1, b2, ...], ...} iff Save_KEY is in the supplied ctx.

**Kind**: inner method of [<code>JSDB</code>](#module_JSDB)  

* [~saveContext()](#module_JSDB..saveContext)
    * [~saveEvents(sql, evs, ctx, cb)](#module_JSDB..saveContext..saveEvents)
        * [~stashify(evs, watchKey, targetPrefix, ctx, stash, cb)](#module_JSDB..saveContext..saveEvents..stashify)

<a name="module_JSDB..saveContext..saveEvents"></a>

#### saveContext~saveEvents(sql, evs, ctx, cb)
Stash aggregated events evs = { at: "AT", ... } into context Save_AT keys then callback cb
with remaining events.

**Kind**: inner method of [<code>saveContext</code>](#module_JSDB..saveContext)  

| Param | Type | Description |
| --- | --- | --- |
| sql | <code>object</code> | sql connection |
| evs | <code>object</code> | events to be saved |
| ctx | <code>object</code> | notebook context |
| cb | <code>function</code> | callback(ev,stat) |

<a name="module_JSDB..saveContext..saveEvents..stashify"></a>

##### saveEvents~stashify(evs, watchKey, targetPrefix, ctx, stash, cb)
Aggregate ctx keys into optional Save_KEY stashes such that:

	[	
		{ at: "KEY", A: a1, B: b1, ... }, 
		{ at: "KEY", A: a2, B: b2, ... }, ... 
		{ x: x1, y: y1 },
		{ x: x2, y: y2 },	...
	].stashify( "at", "Save_", {Save_KEY: {}, ...} , stash, cb )

creates stash.Save_KEY = {A: [a1, a2,  ...], B: [b1, b2, ...], ...} iff Save_KEY is in the
supplied context ctx.   If no stash.rem is provided by the ctx, the {x, y, ...} are 
appended (w/o aggregation) to stash.remainder. Conversely, if ctx contains a stash.rem, 
the {x, y, ...} are aggregated to stash.rem.

**Kind**: inner method of [<code>saveEvents</code>](#module_JSDB..saveContext..saveEvents)  

| Param | Type | Description |
| --- | --- | --- |
| evs | <code>object</code> | events to be saved |
| watchKey | <code>String</code> | this = [ { watchKey:"KEY", x:X, y: Y, ...}, ... } |
| targetPrefix | <code>String</code> | stash = { (targetPrefix + watchKey): { x: [X,...], y: [Y,...], ... }, ... } |
| ctx | <code>Object</code> | plugin context keys |
| stash | <code>Object</code> | refactored output suitable for a Save_KEY |
| cb | <code>function</code> | callback(ev,stat) returns refactored result to put into stash |

<a name="module_JSDB..queueTask"></a>

### JSDB~queueTask()
Regulate task = {Client,Class,Task,Name,QoS,Sign0, ...} into jobs given a supplied clock and callbacks:

	feedcb( err, step ) to feed a record batch into the queue via the stepper step callback 
	taskcb( recs, ctx, res ) to process each record batch in the provided context ctx with responder res callback

When a feedcb is provided, the taskcb is placed into a stream workflow which terminates when the
records batch recs becomes null.  The res(save) callback must be called by the taskcb to advance the task: its 
save context ctx is optional.  The task context ctx is loaded from and saved into its Save_<Class> json store
at each step.

If no feedcb is provided, the taskcb is periodically executed with a null records batch; in this use-case,
the callback to res(save) is optional.

Tasks are identified by Class-Task-Name and increase their Run counter as they are reused.  

A nonzero QoS sets a tasking watchdog timer to manage the task.  

A creditless Client signals a non-null error to the feedcb.

To establish the task as a proposal, set Sign0 = 1.  In so doing, if (Sign1,Sign2,Sign3) are never signed-off 
before the proposal's start time, the task will be killed.

**Kind**: inner method of [<code>JSDB</code>](#module_JSDB)  

* * *

&copy; 2012 ACMESDS
