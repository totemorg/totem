// UNCLASSIFIED

// nodejs modules
const		
	ENV = process.env,
	{ readFile, readFileSync } = require("fs"),
	{ isMaster } = require("cluster");

// 3rd party modules
const
	{ compile } = require('jade'),		//< using jade (now pug) as the skinner	
	JAX = require("mathjax-node");  	//< server-side mathjax parser
	  
// totem modules
const	  
	{ Each,Copy,Log,Debug,typeOf,isString,Fetch, publishPlugins,Start } = require("./enums");

/**
Provides an endpoint to render [DEBE](https://github.com/totemstan/debe) notebooks, datasets, and 
engines using the (possibly dynamically generated) jade associated with the requested 
notebook/table/engine.  Converts [TOTEM markdown](/api.view) to html.  This module 
documented in accordance with [jsdoc]{@link https://jsdoc.app/}.

@module SKIN
@author [ACMESDS](https://totemstan.github.io)

@requires [enums](https://github.com/totemstan/enums)

@requires [fs](https://nodejs.org/docs/latest/api/)
@requires [cluster](https://nodejs.org/docs/latest/api/)

@requires [jade@1.9.0](https://www.npmjs.com/package/jade)

*/
const
	{ Trace, renderJade, errors, skinContext, paths, lookups, skinCtx, blogCtx } = SKIN = module.exports = {
	
	Trace: (msg, ...args) => `skin>>>${msg}`.trace( args ),
		
	config: opts => {
		if (opts) Copy(opts,SKIN,".");
		
		if ( isMaster ) {
			if ( false ) publishPlugins();
			
			if ( jades = paths.jades && false )
				Fetch( jades, files => {  // publish new engines
					var ignore = {".": true, "_": true};
					files.forEach( (file) => {
						if ( !ignore[file.charAt(0)] )
							try {
								Trace("PUBLISHING", file);

								sql.query( "REPLACE INTO openv.engines SET ?", {
									Name: file.replace(".jade",""),
									Code: readFileSync( path+file, "utf-8"),
									Type: "jade",
									Enabled: 0
								});
							}
							catch (err) {
								//Log(err);
							}
					});
				});			
		}
		
		return SKIN;
	},

	publishPlugins: () => { //< publish discovered plugins
		if ( plugins = paths.plugins )
			Fetch( plugins, files => {	// get plugin names to publish
				files.forEach( file => {
					var
						[name,type] = file.split(".");

					if ( type == "js" )
						Fetch( `file:/${name}.pub`, status => {} );
				});	
			});
	},

	paths: {
		//logView: "INSERT INTO openv.dblogs SET ? ON DUPLICATE KEY UPDATE Actions=Actions+1,?",
		getSkin: "SELECT Name,Type,Enabled,Code,State FROM openv.engines WHERE least(?,1) LIMIT 1",
		//cacheSkin: "INSERT INTO openv.engines SET ?",
		jades: "./jades",		// path to default view skins
		jadeRef: "./jades/ref.jade",	// jade reference path for includes, exports, appends		
	},
		
	errors: {
		noSkin: new Error("no such skin"),
		badSkin: new Error("skin contains invalid jade"),		
		noEngine: new Error("requested engine does not exist"),
	},
	
	lookups: {},
	
	blogCtx:	{ //< blogging context
		/**
		Precision to show values in [JSON || #DOC || TEX] OP= [JSON || #DOC || TEX] expansions
		*/

		digits: 4,  // precision to show values in [JSON || #DOC || TEX] OP= [JSON || #DOC || TEX] expansions

		/**
		TeX substitutions.
		*/

		subs: {
			alpha: "\\alpha",
			beta: "\\beta",
			gamma: "\\gamma",
			delta: "\\delta",
			eps: "\\epsilon",
			mu: "\\mu",
			lambda: "\\lambda",
			sigma: "\\sigma",
			nu: "\\nu",
			eta: "\\eta",
			xi: "\\xi",
			omega: "\\omega"
		},

		/**
		Expands LHS := RHS TeX patterns using toEqn
		@returns {string}
		@param {string} lhs 
		@param {string} rhs
		@param {object} ctx
		*/
		":=" : (lhs,rhs,ctx) => toEqn( "", lhs, rhs, ctx), 		// inline TeX

		/*
		"|=" : (lhs,rhs,ctx) => toEqn("a", lhs,rhs,ctx),		// Ascii Match
		";=" : (lhs,rhs,ctx) => toEqn("n", lhs,rhs,ctx),		// break TeX
		">=": (lhs,rhs,ctx) => toTag(lhs,rhs,ctx),				// [post](url) 
		"<=": (lhs,rhs,ctx) => {								// add context value or generator

			if ( rhs.split(",").length > 1) {
				eval(`
	try {
	ctx[lhs] = (lhs,rhs,ctx) => toTag( ${rhs} );
	}
	catch (err) {
	} `);
			}

			else
				ctx[lhs] = rhs.parse$( ctx );

			return ""; 
		},  */

		/**
		Expands [JSON || #DOC || TEX] OP= [JSON || #DOC || TEX] TeX patterns
		@returns {string}
		@param {string} pre prefix
		@param {string} lhs lhs of pattern
		@param {string} rhs rhs of pattern
		@param {object} ctx blogging context
		*/
		toEqn: (pre,lhs,rhs,ctx) => {		// expand [JSON || #DOC || TEX] OP= [JSON || #DOC || TEX] 

			function toTeX(val)  {
				const {digits,subs} = ctx;

				if (val)
					switch (val.constructor.name) {
						case "Number": 
							return val.toPrecision(digits);

						case "String": 
							return val;	

						case "Array": 
							var mat = val[0] || 0;

							if ( mat.forEach ) {
								val.forEach( (vec,idx) => {
									vec.forEach( (arg,idx) => vec[idx] = toTeX(arg) );
									val[idx] = vec.join("&");
								});
								return "\\left[ \\begin{matrix} " + val.join(" \\\\ ") + " \\end{matrix} \\right]";
							}

							else {
								val.forEach( (rec,idx) => val[idx] = toTeX(rec) );
								return  "\\left[ \\begin{matrix} " + val.join(",") + " \\end{matrix} \\right]";
							}

						case "Date": 
							return val+"";

						case "Object": 
							var rtns = [];
							for (var key in val) 
								rtns.push( "{" + toTeX(val[key]) + "}_{" + (subs[key] || key) + "}" );

							return [
								"\\left\\{ \\begin{matrix} ",
								rtns.join( "\\\\ " ),
								" \\end{matrix} \\right\\}"
							].join("");

						default: 
							return JSON.stringify(val);
					}

				else 
					return (val == 0) ? "0" : "\\emptyset";
			}

			function toDoc (arg) {
				var 
					keys = arg.split("#"),
					key = keys[0],
					val = key ? key.parseJS(ctx) : null;

				//Log(">>>>>>>blog", key,val);
				if ( val ) 
					if ( keys.length > 1 ) {
						var rtn = {};
						keys.forEach( (key,idx) => {
							if ( idx ) 
								rtn[key] = val[ key ];
						});
						return rtn;
					}

					else
						return val;

				else 
					return arg.substr(1).parseJS(ctx);
				/*
				switch ( arg.charAt(0) ) {
					case "#":
						arg = arg.substr(1);
						switch (2) {
							case 0:
								return arg.parseJS(ctx);

							case 1:
								var args = [];
								arg.split(",").forEach( arg => args.push(arg.parseJS(ctx)) );
								return args.join(" , ");

							case 2:
								var
									keys = arg.split(","),
									arg = keys[0].parseJS(ctx);

								Log(">>>arg", arg,keys);
								return arg;
						}

					default:
						var args = arg.split(",");
						return (args.length>1) ? args : arg;
				}*/
			} 

			//Log(">>>eqn", lhs, rhs);
			return pre + "$$ " + toTeX(lhs) + " = " + toTeX(rhs.parseJSON(toDoc)) + " $$";
		},

		toTag: (lhs,rhs,ctx) => {
			var
				lKeys = lhs.split(","),
				rKeys = rhs.split(","),
				base = lKeys[0] + "$.",
				skin = rKeys[0],
				args = (rKeys[3] || "").replace(/;/g,","),
				opts = {
					w: rKeys[1],
					h: rKeys[2],
					x: lKeys[1] ? base + lKeys[1] : "",
					y: lKeys[2] ? base + lKeys[2] : "",
					r: lKeys[3] ? base + lKeys[3] : ""
				};

			for (var key in opts) if ( !opts[key] ) delete opts[key];

			//Log( base, view, "[post](/" + (skin+".view").tag("?",opts)+args + ")" );
			return "[post](/" + `${skin}.view`.tag("?",opts)+args + ")";
		}
	},
		
	skinCtx: {	//< default skinning context
	},
		
/**
Callback cb with skinning context ctx for requested table.

@param {Object} req Totem request
@param {Function} cb callback(ctx)
*/
	skinContext: function (sql, ctx, cb) {
		
		const 
			{ table , query, flags, type, ds, name } = ctx,
			{ urls } = skinCtx,
			{ getSkin } = paths,
			verbose = type != "run";
			  
		//Log(">>>skin ctx", ctx);
		sql.query( 	// get engine info
			//"SELECT Type FROM openv.engines WHERE ? LIMIT 1", 
			getSkin, {
				Name: name,
				Type: "jade",
				Enabled: 1
			}, (err,engs) => {

			const
				eng = engs[0] || {Type: ""};

			Copy({		// prime skinning context 
				engine: eng.Type,

				/*
				Drop notebook html interface into the current skin.  As this i/f contains 
				html content itself (e.g. the html content generated for each i/f key when 
				the notebook was published), the returned i/f html needs to be escaped,
				typically using the "$with x=interface():\n\t${x}\n\n" skinning escape
				in the hosting skin.
				*/
				interface: () => {
					const
						ifs = [], 
						{ fields } = ctx;

					fields.forEach( f => {
						ifs.push({ 
							Key: f.Field, 
							Type: f.Type, 
							Details: unescape(f.Comment || "missing")
						});
					});
					return ifs.gridify();
				},

				flags: flags
			}, ctx);

			sql.query(	// get collaborators
				"SELECT group_concat(concat('<a href=\"emailto:',Client,'\">',Client,'/a>+',Actions)) AS Colabs FROM openv.dblogs WHERE Dataset=? ORDER BY Actions desc", 
				table, (err,recs) => {

	//Log("skin colab", err||recs);

				ctx.colabs = recs[0].Colabs;

				//Log(">>>>getkeys", table, type, verbose);
				sql.query( 	// get keys
					verbose
						? "SHOW FULL COLUMNS FROM ?? WHERE Type != 'timestamp' AND Type != 'geometry' "
						: "SHOW FULL COLUMNS FROM ?? WHERE Type != 'timestamp' AND Type != 'geometry' AND Field NOT LIKE 'Save%' "
					, [ds], (err,fields) => {

					//if (!verbose) Log(">>>show", ds, err, fields);
					ctx.fields = err ? null : fields;

					sql.query(	// get project info
						"SELECT * FROM openv.projects WHERE ? LIMIT 1", 
						{Name: name}, (err,projs) => {

						const proj = ctx.proj = projs[0] || { JIRA: "tbd", Status: "tbd", Name: ctx.name, Title: ctx.name, Lead: "tbd" };

						sql.query(		// get RAS/subcontractor info
							"SELECT group_concat(RAS) AS RAS FROM openv.milestones WHERE ? AND RAS", 
							{Project: ctx.name}, (err, vendors) => {

							sql.query(
								"SELECT Seq, group_concat('Q:',Q,'A:',A) AS QA FROM openv.faqs WHERE ? GROUP BY Seq",
								{Name: ctx.name}, (err, faqs) => {

								function getArtifacts( ctx, cb ) {
									Fetch( `file:/artifacts/${ctx.name}/`, files => {
										var 
											id = 1,
											Files = ctx.files = {
												deck: {},
												image: [],
												artifact: [],
												misc: [],
												live: []
											},
											Batch = {
												jpg: "image",
												png: "image",
												gif: "image",
												mpeg: "image",
												mp4: "image",
												avi: "image",
												mov: "image",
												ppt: "artifact",
												pptx: "artifact",
												txt: "artifact",
												doc: "artifact",
												pdf: "artifact",
												docx: "artifact",
												html: "live",
												default: "misc"
											};

	//Log("art files", files);
										
										if ( files )
											files.forEach( file => {
												var 
													path = `.${book}/${file}`,
													parts = file.split("_"),
													num = 0,
													classif = [],
													type = "",
													title = [],
													depth = 1;

												parts.forEach( (part,n) => {
													switch (part) {
														case "":
															depth++;
															break;
														case "S":
														case "U":
														case "TS":
														case "C":
														case "FOUO":
														case "LIMDIS":
														case "NF":
														case "ORCON":
														case "FVEY":
														case "NATO":
															classif.push( part );
															break;
														default:
															if ( n = parseFloat(part) )
																num = n;

															else {
																var parts = part.split(".");
																title.push( parts[0] );
																type = (parts[1] || "").toLowerCase();
															}
													}
												});

												switch ( type ) {
													case "":
													case "rdp":
													case "url":		// discard
														break; 

													case "lnk":		// re-path it then batch it
														try {	
															readFileSync( path, "utf8" ).replace( /\&(.*)\+/, (pre,goto) => {
																path = goto.replace(".\\", "/notebooks/"); // assume local link
																//Log(">>>goto", path);
															});
														}
														catch (err) { // keep as is
														}

													default:
														var 
															set = `set${depth}`,
															stack = ( depth && num ) 
																	? Files.deck[set] || ( Files.deck[set] = [] )
																	: Files[ Batch[type] || Batch.default ];

														//Log(title, type, depth, num, set, stack.constructor);
														stack.push( {
															id: id++,
															num: num, 
															title: title.join(" "), 
															classif: ("(" + classif.join("//") + ")").replace("()","(U)"),
															type: type, 
															name: file, 
															parts: parts.length-1, 
															path: path, 
															link: title[0].link( path ) 
														} );
													}
											});

										Each( Files.deck, (set,files) => Files.deck[set] = files.sort( (a,b) => a.num-b.num ) );

	//Log("file ctx", Files);

										cb(ctx);
									});
								}

								function getDatasets( ctx, cb ) {
									const
										data = ctx.data = {};

									Fetch( `file:/artifacts/${ctx.name}/data/`, files => {
										
	//Log(">>>>>>>>>>>>>>ds files", files);
										
										if ( files ) {
											var
												toRead = files.length,
												read = 0;

											files.forEach( file => {
												const
													path = `.${book}/${file}`,
													[x,name,type] = file.match( /(.*)\.(.*)/ ) || [file,""];

												//Log(">>>>>>>>>>>>>>>reading", name,type);
												switch ( type ) {
													case "xslx":
													case "csv":
														if ( ++read == toRead ) cb(ctx);
														break;

													case "js":
														CP.exec(`node ${path}`, (err,log) => {
															data[name] = err || log;
															if (++read == toRead) cb(ctx);
														});
														break

													case "py":
														CP.exec(`python ${path}`, (err,log) => {
															data[name] = err || log;
															if (++read == toRead) cb(ctx);
														});
														break

													case "url":
														const
															[x,pre,url] = readFileSync( path, "utf8" ).match( /(.*)URL=(.*)\r\n/ );

														//Log(" >>>>>url read=", {txt: readFileSync( path, "utf8" ), url:url} );

														if ( url ) 
															Fetch(url, txt => {
																data[name] = txt;
																if ( ++read == toRead ) cb(ctx);
															});

														else
														if ( ++read == toRead ) cb(ctx);

														break;

													default:
														data[name] = readFileSync( path, "utf8" );
														if ( ++read == toRead ) cb(ctx);
												}
											});

											if ( !toRead ) cb(ctx);
										}
										
										else
											cb(ctx);
									});
								}

								const vendor = vendors[0] || { RAS: "none" };

								proj.RAS = vendor.RAS || "none";

	// Log(">proj", proj);
								getArtifacts( ctx, ctx => {
									const 
										{table,engine,host} = ctx;

	//Log(">>>>>>>>>>>> env host", host);
	//Log(">>>>>>>>>>>>>>repo", skinCtx.repo, `${skinCtx.repo}/artifacts/tree/master/${name}` );								
									const 
										name = table,
										Name = name.toUpperCase(),
										book = "/" + name,
										urls = {
											_exe: `/${name}.exe?name=CASE`,
											_run: `/${name}.run`,
											_view: `/${name}.view`,
											_tou: `/${name}.tou`,
											_publish: `/${name}.pub` ,
											_export: `/${name}.export`,
											_import: `/${name}.import`,
											_artifacts: `/explore.view?src=/root/artifacts/${name}/`,
											_brief: `/brief.view?_project=${name}`,
											_clone: `/${name}.${ctx.engine}`,
											_repo: `${skinCtx.REPO}/artifacts/tree/master/${name}`,
											_jira: `${skinCtx.JIRA}/project=${proj.JIRA}`,										
											_ras: `${skinCtx.RAS}/project=${proj.RAS}`,
											_rtp: `/rtpsqd.view?_project=${name}`,
											_reset: `${name}.reset`,
											_repofiles: `${skinCtx.repo}/${name}/raw/master`,
											_relinfo: `/releases.html?nb=${name}`
										},
										links = {};

									Object.keys(urls).forEach( _key => links[_key] = _key.substr(1).link( urls[_key] ));

	//Log(">>>>>>>>>>>links", links);

									Copy(urls, Copy(skinCtx, Copy({
										Name: Name,

										faqs: faqs,

										register: () => 
											"<!---parms endservice=https://myservice/" + ctx.name + "--->" 
											+ ctx.input({a:"aTest", b:"bTest"}),

										//input: tags => "<!---parms " + "".tag("&", tags || {}).substr(1) + "--->",

										summary: "summary tbd",
										ver: "ver tbd",
										reqs: {
											distrib: "request to distribute NAME/Can you grant permission to distribute NAME?".replace(/NAME/g, Name),
											info: "request for information on NAME/Can you provide further information on NAME?".replace(/NAME/g, Name),
											help: "need help on NAME/Please provde me some help on notebook NAME".replace(/NAME/g, Name)
										},
										request: req => {
											var
												parts = (req || ctx.reqs.info || "request/need information").split("/"),
												label = parts[0] || "request",
												body = parts[1] || "request for information",
												pocs = ctx.pocs || {};

											//Log("pocs", pocs, label, body, name, req);
											return (pocs.admin||"").mailify( label, {subject: name, body: body} );
										},

										//interface: () => "publish notebook to define interface",
										now: (new Date()).toUTCString(),

										//loopback: host + "." + engine +"?endservice=" + host +".users",
										//transfer: host + "." + engine + "?endservice=",
										//totem: host,
										//api: host + "/api.view",

										uses: Object.keys(links).map( _key => links[_key] ).join(" || "),

										// windows ie
										// "file://164.183.33.7/totem/notebooks/" + name,
										// windows ff
										// "file://///164.183.33.7/totem/notebooks/" + name,
										// linux
										//"file://local/service/debe/notebooks/" + name,

										//brief: "/brief.view?notebook=" + name,
										//rtp: "/rtpsqd.view?notebook=" + name,

									}, ctx)));

	//Log(">>>>>>>>>ctx", ctx);
									Object.keys(urls).forEach( _key => {	// mutate urls
										const 
											url = ctx[_key],
											key = _key.substr(1),
											Key = key.charAt(0).toUpperCase()+key.substr(1),
											KEY = key.toUpperCase(),
											$Key = "$"+Key,
											$key = "$"+key,
											$KEY = "$"+KEY;

										ctx[$KEY] = `$embed{${url}}`;
										ctx[$Key] = Key.link( url );
										ctx[$key] = key.link( url );
									});

									getDatasets(ctx, ctx => {
										cb(ctx);
									});
								});
							});
						});
					});
				});				
			});
		});	
	},
	
/**
Render jade string to callback cb( err || html ) in a new context created for 
this request. 

@param {String} jade contents to render
@param {Object} ctx skinning context
@param {Function} cb callback(ctx)
**/
	renderJade: function ( jade, ctx, cb ) { 
		ctx.skin = jade;				// forgot who needs this
		ctx.filename = paths.jadeRef;	// jade compiler need to resolve extends

//Trace("render jade", ctx);
		//Log("files", ctx.files.deck.set1.map( file => [file.num, file.title] ));
		
		try {
			//jade.Xblog( ctx, jade => cb( compile(jade, ctx) (ctx) ) );			
			
			cb( compile(jade, ctx) (ctx) );	
			
			//(compile(jade, ctx) (ctx)).Xblog( ctx, html => cb(html) );
			
			//(compile(jade, ctx) (ctx)).Xinclude( "", html => cb(html) );
			//(compile(jade, ctx) (ctx)).Xinclude( "", html => html.Xfollow( "", ctx, html => cb(html) ) );
			//jade.Xkeys( ctx, jade => cb( compile( jade, ctx)(ctx) ) );
			//jade.Xkeys( ctx, jade => (compile( jade, ctx)(ctx)).Xinclude( "", html => cb(html) )  );
			//jade.Xinclude( "", ctx, jade => cb( compile(jade, ctx) (ctx) ) );
			//(compile(jade, ctx) (ctx)).Xiframe( "", html => cb(html) );
		}
		
		catch (err) {
			//Log("render jade", err);
			cb( err+"" );
		}
	},
	
/**
Endpoint to render req.table using associated jade engine. 

@param {Object} req Totem request
@param {Function} res Totem response
*/
	renderSkin: function (req,res) {
		function renderFile( file, ctx, cb ) { 

//Trace("skin render file", file);
			readFile( file, "utf-8", (err,jade) => {
				if (err) 
					cb( errors.noSkin );

				else {
					const 
						{table,opts} = ctx,
						{cacheSkin} = paths;
					
					if (cacheSkin)
						sql.query( cacheSkin, {
							Name: table,
							Type: "jade",
							Code: jade,
							Enabled: true,
							Client: "totem",
							State: opts ? JSON.stringify(opts) : null
						});

					renderJade( jade, ctx, cb );
				}
			})
		}

		/*
		Render Jade file at path this to res( err || html ) in a new context created for this request.  
		*/
		function tableCols( fields ) { // render table using jade plugin

			const 
				cols = [],
				quals = { ID:"hide", id:"hide", timestamp: "drop", geometry: "drop" },
				saver = "Save",
				grouper = "_";

			switch ( typeOf(fields) ) {
				case "Array":	
					fields.forEach( field => {
						var 
							Key = field.Field, 
							Type = field.Type.split("(")[0],
							Tip = field.Comment || "",
							Qual = quals[Key] || ""; 
// Log(">>>>skin", Key, Type, Qual);

						if ( !Qual ) {
							if ( select = lookups[Key] ) {
								Type = "select"; 
								Qual = select; 
							}

							else
							if ( Key.startsWith(saver) )
								Qual = "lock"; 

							else
							if ( Key.startsWith(grouper) ) 
								Qual = "lock";
						}
						
						if ( Qual != "drop" )
							cols.push( Key + "." + Type + "." + Tip + "." + Qual );
					});

					break;

				case "String":
					fields.split(",").forEach( field => {
						if ( field != "ID") cols.push( field );
					});	
					break;

				default:
					Each(fields, field => {
						if (field != "ID") cols.push( field );
					});	
			}

			return cols.groupify(grouper);
		}

		const
			{sql,path,table,url,now,client,flags,type,query,referer,site,ds,profile} = req,
			ctx = Copy(site, {
				//name: ds.split(".")[1]
				query: query,
				table: table,
				flags: flags,
				type: type,
				client: client,
				ds: ds,
				url: url,
				profile: profile,
				$refer: new URL(referer || "http://localhost:8080"),
				name: flags.project || table
			});
		
		skinContext(sql, ctx, ctx => {
//Trace("get ctx", ctx);
			
			if (ctx) { // render skin
				const 
					{name,type,fields,flags,query} = ctx,
					{logView,getSkin } = paths;
				
				//Log("skin check", name,table,type, flags, "isTable=", fields?true:false);
				
				if (logView)
					sql.query( logView, [{
						Op: "view",
						Event: now,
						Dataset: (name==table) ? table : name,
						Client: client
					}, {
						Event: now
					}]);

				sql.query( getSkin, { 		// look for skinning engine
					Name: table,
					Type: "jade",
					Enabled: 1
				}, (err,engs) => {

					if ( eng = engs[0] ) {	// render using cached jade engine
						ctx.opts = eng.State ? eng.State.parseJSON({
							ds: table,
							mode: type,
							cols: "",
							query: query
						}) : null;
						renderJade( eng.Code || "", ctx, html => res(html) );
					}

					else 					// render using file then update engine cache						
						if ( fields ) {		// render plugin/notebook table
							ctx.opts = {
								ds: table,
								mode: type,
								cols: tableCols( fields ),
								query: query
							};
							renderFile( `${paths.jades}/plugin.jade`, ctx, html => res(html) );
						}

						else { 				// render jade file
							ctx.opts = null;
							renderFile( `${paths.jades}/${table}.jade`, ctx, html => res(html) );	
						}
				});
			}
			
			else
				res( errors.noEngine );
		});
	}
};

const
	{ toEqn, toTag } = blogCtx;


/**
Short form of blogify.

@param {Object} ctx initial blogging context
@param {Function} cb callback accepting the resulting html
*/
function blog(ctx, cb) {
	this.blogify("",  {}, ctx, cb);
}

/**
Expands markdown:

	$ VIEW { SRC ? w=WIDTH & h=HEIGHT & x=KEY$INDEX & y=KEY$INDEX ... }  
	$ { JS }   
	[ LINK ] ( URL )  
	$ $ inline TeX $ $ || n$ $ break TeX $ $ || a$ $ AsciiMath $ $ || m$ $ MathML $ $
	TeX := TeX || #VAR || VAR#KEY#KEY...
	# SECTION  
	ESCAPE || $with || $for || $if:\\n \\t BLOCK \\n

to html.

@param {Object} ctx initial blogging context
@param {String} src default source path
@param {Object} rec source record
@param {Function} cb callback accepting the resulting html
*/
function blogify(src, ctx, rec, cb) {

	Copy(blogCtx, ctx);

	//Log(">>>blog", ctx, src, rec,"src>>>>",this+"");
	//Log(">>>blog", this);

	/*
	ctx.ab = args => {		// add key abbrevators
		if ( args)
			switch (args.constructor.name) {
				case "Array":
					args.forEach( (arg,idx) => ctx[ `_${idx}` ] = arg );
					break;

				case "Object":
					Each(args, (idx,arg) => ctx[ `_${idx}` ] = arg );
					break;

				case "String":
					ctx.ab( ctx[ `Save_${args}` ] );
			}		

		return "";
	};  */
	//Log(">>>>blogify", this, src);

	// ctx.$ = $; 	// add $man array functions

	for (var key in rec)  { // parse and abbreviate json stores
		try { 
			ctx[key] = JSON.parse( rec[key] ); 
		} 
		catch (err) { 
			ctx[key] = rec[key]; 
		}

		if ( key.startsWith("Save_") ) // abbreviate
			ctx[ key.substr(4) ] = ctx[key];
	}

	this
	.replace(/<!--.*-->/g, "")
	.replace(/^! /gm, str => "\t")
	.replace(/^!!/gm, str => "\n")
	.Xescape( [], ctx, (html,blocks) => // escape code blocks
	html.Xbreaks( html => // force new lines
	html.Xgrid( html => // expand grids
	html.Xsection( html => // expand section headers
	html.Xkeys( ctx, html => // expand js keys
	html.Xoper(ctx, html => // expand operators
	html.Xtex( html => // expand TeX
	html.Xlink( html => // expand links
	html.Xembed( html => 	// expand embeds
	html.Xview( src, ctx, html => 	// expand embeds
	html.Xfollow( src, ctx, html => // spoof href links
	html.Xbacksub( blocks, html => cb(html) // backsub code blocks
	))))))))))));
}
	
[  // string prototypes
	blog,
	blogify,
	
	function Xbreaks( cb ) {	// expand hard line breaks
		cb( this.replace( /  \n/g, "<br>" ) );
	},
	
	/*
	function Xescape( blocks, ctx, cb ) { // callback cb(blocks, escaped blocks)
		var 
			key = "@esc",
			fetchBlock = function ( rec, cb ) {	// callsback cb with block placeholder
				//Log(`block[${blocks.length}] `, rec.arg1 );
				var 
					debug = false,
					stmt = rec.arg1 || "",
					block = rec.arg2 || "",
					stmt = stmt.replace(/^\$(.*) (.*)/, (str,op,src) => {	// replace enumerators
						
						//Log(">>esc", op,src);
						
						if ( Src = src.parseJS(ctx) ) {	// valid enumerator var provided
							var 
								rtn = "",
								N = Src.forEach ? Src.length : Object.keys(Src).length;
							
							ctx._a = src;
							ctx._n = N;
							//Log(">>>",op,src,block);
						
							switch (op) {	// treat enumerator
								case "with":
									blocks.push( Src );
									cb( "@block" );
									/ *block = ctx.interface();
									Log(">>>if", block);
									blocks.push( block );
									cb( "@block" );	* /
									break;
									
								case "for":
								case "enum":
								case "each":
									if ( Src.forEach )
										for ( ctx._i=0; ctx._i<N; ctx._i++ ) 
											rtn += block.parse$(ctx)+" ";
									
									else
									if ( Src.length )
										rtn += block.parse$(ctx)+" ";
									
									else
										for ( ctx._i in Src ) 
											rtn += block.parse$(ctx)+" ";
									
									cb( rtn );
									break;

								case "skip":
								case "nada":
								case "//":
								case "comment":
									cb("");
									break;
									
								case "trace":
								case "dump":
								case "debug":
									cb("?"+op);
									break;
									
								case "if":
									cb( block.parse$(ctx)+" " );
									break;
									
								case "do":
								case "until":
								default:
									cb("?"+op);
									break;
							}
						}
						
						else
							cb( "" )
							
						return "$";
					});

				//Log(">>escape",block, stmt);
				if ( stmt != "$" ) {
					blocks.push( block );
					cb( stmt + ":" + "@block" );
				}
			},
			pattern = /(.*)\:\n((\t.*\n)+)\n/gm;
		
		//Log("Xescape", this.match( pattern ) );
		this.serialize( fetchBlock, pattern, key, html => cb( html, blocks) ); 		
	},  */
	
	function Xgrid( cb ) {
		cb( this.replace(/\n((\n\|.*)+)\n/gm, (str,guts) => {
			//console.log("grid>>>>", [guts]); 
			const 
				rows = guts.split("\n"),
				keys = rows[1].split("|"),
				just = [""],
				grid = [];
			
			rows.forEach( (row,n) => { 
				if ( n == 2 ) 
					row.split("|").forEach( (val,m) => {
						if ( m ) {
							if ( val.startsWith(":") && val.endsWith(":") ) just.push("C");
							else
							if ( val.startsWith(":") ) just.push("L");
							else
							if ( val.endsWith(":") ) just.push("R");
							else
								just.push("C");
						}
					});
					
				else
				if ( n > 2 ) {
					const rec = {};
					row.split("|").forEach( (val,m) => {
						if ( m ) rec[keys[m]] = val;
					});
					grid.push(rec);
				}
			});
			
			//console.log(just, grid);
			return grid.gridify(false);
		}) );
	},
	
	function Xescape( blocks, ctx, cb ) { // callback cb(blocks, escaped blocks)
		cb( this.replace( /(.*)\:\n((\t.*\n)+)\n/gm , (str,stmt,block) => {
			//Log("escape", stmt, block);
			
			var 
				debug = false,
				stmt = stmt.replace(/^\$(.*) (.*)/, (str,op,src) => {	// replace enumerators

					//Log(">>esc", op,src);

					if ( Src = src.parseJS(ctx) ) {	// valid enumerator var provided
						var 
							rtn = "",
							N = Src.forEach ? Src.length : Object.keys(Src).length;

						ctx._a = src;
						ctx._n = N;
						//Log(">>>",op,src,block);

						switch (op) {	// treat enumerator
							case "with":
								blocks.push( Src );
								cb( "@block" );
								/*block = ctx.interface();
								Log(">>>if", block);
								blocks.push( block );
								cb( "@block" );	*/
								break;

							case "for":
							case "enum":
							case "each":
								if ( Src.forEach )
									for ( ctx._i=0; ctx._i<N; ctx._i++ ) 
										rtn += block.parse$(ctx)+" ";

								else
								if ( Src.length )
									rtn += block.parse$(ctx)+" ";

								else
									for ( ctx._i in Src ) 
										rtn += block.parse$(ctx)+" ";

								cb( rtn );
								break;

							case "skip":
							case "nada":
							case "//":
							case "comment":
								cb("");
								break;

							case "trace":
							case "dump":
							case "debug":
								cb("?"+op);
								break;

							case "if":
								cb( block.parse$(ctx)+" " );
								break;

							case "do":
							case "until":
							default:
								cb("?"+op);
								break;
						}
					}

					else
						cb( "" )

					return "$";
				});

			//Log("escaped", stmt, block);
			if ( stmt != "$" ) {	// not a control statement
				blocks.push( block );
				return stmt + ":" + "@block";
			}
			
			else
				return "";

			//Log("escape blocks", blocks);
			
		}), blocks );
	},
	
	function Xdummy(cb) {  // for debugging with callback(this)
		cb(this);
	},
	
	/*
	function Xlink( cb ) {  // expand [NAME](LINK)
		var 
			key = "@link",
			fetch = function ( rec, cb ) {  // expand markdown
				var
					url = rec.arg2,
					opt = rec.arg1 || url ;

				cb( opt.link( url ) );
			},
			pattern = /\[([^\[\]]*)\]\(([^\)]*)\)/g ;
		
		// Log("Xlink", this.match(pattern));
		this.serialize( fetch, pattern, key, html => cb(html) ); 
	}, */
	
	function Xlink( cb ) {  // expand [NAME](LINK)
		cb( this.replace( /\[([^\[\]]*)\]\(([^\)]*)\)/g, (str,lab,url) => lab.link(url) ) );
	},
	
	/*
	function Xtopic( req, cb ) {	// callback with tag{TOPIC} markdown
		var 
			key = "@top",
			fetch = function ( rec, cb ) {  // expanded markdown
				var 
					secret = "",
					topic = rec.topic,
					product = topic+".html";

				if (req)		// content tracking enabled
					if ( licenseCode )
						licenseCode( req.sql, html, {  // register this html with the client
							_Partner: req.client,
							_EndService: "",  // leave empty so lincersor wont validate by connecting to service
							_Published: new Date(),
							_Product: product,
							Path: "/tag/"+product
						}, (pub, sql) => {
							if (pub) {
								cb( `${rec.topic}=>${req.client}`.tag( "/tags.view" ) );
								sql.query("INSERT INTO app.tags SET ? ON DUPLICATE KEY UPDATE Views=Views+1", {
									Viewed: pub._Published,
									Target: pub._Partner,
									Topic: topic,
									License: pub._License,
									Message: "get view".tag( "/decode.html".tag("?",{Target:pub._Partner,License:pub._License,Topic:topic}))
								});
							}
						});
				
					else
						Trace( "NO LICENSOR", req );
				
				else	// content tracking disabled
					cb( "" );
			},	
			pattern =  /tag\{(.*)\}/g;  // /\~\{([^\}]*)\}/g;
			
		this.serialize( fetch, pattern, key, html => cb(html) ); 
	},*/
	
	/*
	function Xembed( src, ctx, cb ) {	// expand $EMBED{QUERY}
		var 
			key = "@embed",
			
			Xfetch = function ( rec, cb ) {  // expand markdown
				var
					view = rec.arg1,
					url = rec.arg2,
					keys = {src:src},
					isRef = url.charAt(0) == "$",
					[path] = (isRef ? ctx[url.substr(1)] : url).parsePath(keys,{},{},{}),
					w = keys.w || 200,
					h = keys.h || 200;
				
				Log(">>embed", [view, keys, url, path]);
						
				switch (view) {
					case "image":
					case "img":
						cb( "".tag("img",{href:path,width:w,height:w}) );
						break;
						
					case "embed":
						Log(">>>embed host=",url);
						Fetch( url, res => {
							//Log(">>>embed", res);
							cb(res);
						});
						break;
						
					default:
						//Log( "".tag("iframe", { src: `/${view}.view`.tag( "?", keys ), width:w, height:h }) );
						
						if ( path )
							cb( path.tag( "a", {href: `${view}.view`.tag( "?", keys )}) );
						
						else
							cb( "".tag("iframe", { src: `${view}.view`.tag( "?", keys ), width:w*1.1, height:h*1.1 }) );
				}
			},
			
			pattern = /\$(\w+){(.*)}/g; 
		
		//Log("Xembed", this.match( pattern ) );
		
		this.serialize( Xfetch, pattern, key, html => cb(html) ); 
	}, */
	
	function Xview( src, ctx, cb ) {	// expand $VIEW{QUERY}
		cb( this.replace( /\$(\w+){(.*)}/g, (str,view,url) => {

			const
				keys = {src:src},
				isRef = url.charAt(0) == "$",
				[path] = (isRef ? ctx[url.substr(1)] : url).parsePath(keys,{},{},{}),
				w = keys.w || 200,
				h = keys.h || 200;

			// Log("view", view, keys, url, path);

			switch (view) {
				case "image":
				case "img":
					return "".tag("img",{href:path,width:w,height:w});
					break;

				default:
					//Log( "".tag("iframe", { src: `/${view}.view`.tag( "?", keys ), width:w, height:h }) );

					if ( path )
						return path.tag( "a", {href: `${view}.view`.tag( "?", keys )}) ;

					else {
						// Log( "".tag("iframe", { src: `${view}.view`.tag( "?", keys ), width:w*1.1, height:h*1.1 }) );
						return "".tag("iframe", { src: `${view}.view`.tag( "?", keys ), width:w*1.1, height:h*1.1 }) ;
					}
			}				

		}) );
	},
	
	function Xembed( res ) {	// expand $embed{QUERY}
		this.replaceSync( /\$embed{(.*)}/g, (args,cb) => {  
			
			if (cb) {
				const
					[str,url] = args;
				
				//Log("embed", url);
				
				if ( false )
					Fetch( url, res => {	// cant embed all this html
						//Log(">>>embed", res);
						cb(res);
					});
				
				else
					cb( "".tag("iframe",{src:url,width:500,height:200}) );
			}
			
			else
				res(args);
					
		});
	},

	/*
	function Xiframe( ds, cb ) {	// expand <iframe></iframe>
		var 
			key = "@frame",
			
			fetch = function ( rec, cb ) {  // expand markdown
				Fetch(rec.arg1, cb);
			},
			
			pattern = /<iframe src=["|'](.*?)["|'](.*)<\/iframe>/g;
		
		//Log("Xiframe", this.match( pattern ) );
		
		this.serialize( fetch, pattern, key, html => cb(html) ); 
	}, 
	*/
	
	function Xblog( ctx, cb ) {	// expand <blog>BLOG</blog>
		var 
			key = "@blog",
			
			fetch = function ( rec, cb ) {  // expand markdown
				rec.arg1.blogify("",ctx, {}, cb);
			},
			
			pattern = /<blog>((.|\n)*)<\/blog>/g;
		
		//Log(">>>>xblog", this);
		
		this.serialize( fetch, pattern, key, html => cb(html) ); 
	},
	
	/*
	function Xblog(ctx,cb) {
		this.Xkeys(ctx, html => html.Xembed("",ctx,cb));
	}, */
		
	function Xfollow( ds, ctx, cb ) { // expand <a>NAME</a>
		if ( true ) 
			cb (this );
		else
			cb( this.replace( /href=['|"]([^'"]*)/g, (str,ref) => { // smart links to follow
				var 
					key = ctx[ref] || ref;

				//Log(">>>>>>>>>>href", ref, key);
				if ( ds )	// blogging via browser
					return `href="javascript:navigator.follow(${key},BASE.user.client,BASE.user.source)">`;

				else
					return `href="${key}"`;
			}) );
	},

	function Xbacksub( blocks, cb ) {	// backsub escaped blocks	
		var blockidx = 0;
		
		//Log(">>xback", this);
		cb( 
			this.replace(/@block/g, str => {  	
				//Log(`unblock[${blockidx}]`, blocks[blockidx]);
				return blocks[ blockidx++ ].tag("code",{}).tag("pre",{});
			}) 
		);
	},	

	function Xscript( ctx, cb ) {  // callback with vmctx, expanded scripts
		var 
			script = "",
			pattern = /script:\n((.|\n)*)/g,  // defines MARKDOWN\nscript:\SCRIPT tag pattern
			run = this.replace( pattern , (str, xscript) => {
				script = xscript;
				return "";
			});
		
		if ( script )
			try {
				$( script, ctx, (vmctx) => {
					cb( vmctx , run);
				});
			}
			catch (err) {
				cb( ctx, err+"");
			}
		
		else 
			cb(ctx, run);
	},
		
	function Xkeys( ctx, cb ) {  // expand ${key}
		//Log("xkeys", this.parse$(ctx) );
		cb( this.parse$(ctx) );
	},
	
	function Xoper( ctx, cb ) {  // expand LHS := RHS

		var 
			pattern = /(\S*) := (\S*)/g;  
		
		cb( this.replace(pattern, (str,lhs,rhs) => {
			//Log([":=", lhs, rhs]);
			if ( blogOp = ctx[":="] ) 
				return blogOp(lhs,rhs,ctx);
			else
				return "?";
		}) );
	},
	
	/*
	function Xtex( cb ) {  // expand X$$ MATH $$
		var 
			key = "@tex",
			fetch = function ( rec, cb ) {	// callsback cb with expanded TeX tag
				//Log("math",rec);
				switch (rec.arg1) {
					case "n":
						JAX.typeset({
							math: rec.arg2,
							format: "TeX",  
							//html: true,
							mml: true
						}, d => cb( d.mml || "" ) );
						break;
					case "a":
						JAX.typeset({
							math: rec.arg2,
							format: "AsciiMath",
							//html: true,
							mml: true
						}, d => cb( d.mml || "" ) );
						break;
					case "m":
						JAX.typeset({
							math: rec.arg2,
							format: "MathML", 
							//html: true,
							mml: true
						}, d => cb( d.mml || "" ) );
						break;
					case " ":
					default:
						JAX.typeset({
							math: rec.arg2,
							format: "inline-TeX",  
							//html: true,
							mml: true
						}, d => cb( " " + d.mml || "" ) );
				}
			},
			pattern = /(.?)\$\$ ([^\$]*) \$\$/g;
			
		this.serialize( fetch, pattern, key, html => cb(html) ); 
	}, */
	
	/*
	function Xtex( res ) {  // expand X$$ MATH $$
		this.replaceSync( /(.?)\$\$ ([^\$]*) \$\$/g, (args,cb) => {

			//Log("tex", args, cb?true:false);
			
			if ( cb ) {
				const [ str, op, math ] = args;
				Log("tex", op, math);
				switch ( op ) {
					case "n":
						JAX.typeset({
							math: math,
							format: "TeX",  
							//html: true,
							mml: true
						}, d => cb( d.mml || "" ) );
						break;
					case "a":
						JAX.typeset({
							math: math,
							format: "AsciiMath",
							//html: true,
							mml: true
						}, d => cb( d.mml || "" ) );
						break;
					case "m":
						JAX.typeset({
							math: math,
							format: "MathML", 
							//html: true,
							mml: true
						}, d => cb( d.mml || "" ) );
						break;
					case " ":
					default:
						JAX.typeset({
							math: math,
							format: "inline-TeX",  
							//html: true,
							mml: true
						}, d => cb( " " + d.mml || "" ) );
				}
			}

			else
				res(args);

		});
	},  */
	
	function Xtex( cb ) {  // expand X$$ MATH $$
		cb( this.replace( /(.?)\$\$ ([^\$]*) \$\$/g, (str,op,math) => {

			var rtn = "";
			
			//Log("tex", op, math);
			switch ( op ) {
				case "n":
					JAX.typeset({
						math: math,
						format: "TeX",  
						//html: true,
						mml: true
					}, d => rtn = d.mml );
					break;
				case "a":
					JAX.typeset({
						math: math,
						format: "AsciiMath",
						//html: true,
						mml: true
					}, d => rtn = d.mml );
					break;
				case "m":
					JAX.typeset({
						math: math,
						format: "MathML", 
						//html: true,
						mml: true
					}, d => rtn = d.mml );
					break;
				case " ":
				default:
					JAX.typeset({
						math: math,
						format: "inline-TeX",  
						//html: true,
						mml: true
					}, d => rtn = " " + d.mml );
			}

			//Log("tex", rtn);
			return rtn;
		}) );
	},
	
	function Xparms( goto, cb ) {		// expand <!---parms KEY=VAL&...--->
		var
			pattern = /<!---parms ([^>]*)?--->/g;
		
		cb( this.replace(pattern, (str, parms) => {
					
			//Log(">>>Xparms", parms);
			
			var 
				inputs = [],
				keys = [];

			parms.split("&").forEach( (parm) => {  // each collect parm (key=value) needs an input
				parm.replace(/([^=]*)?=(.*)?/, (str, key, val) => {		// key=value
					inputs.push( `${key}: <input id="parms.${key}" type="text" value="${val}" autofocus >` );
					keys.push( '"' + key + '"' );
					return "";
				});
				return "";
			});

			// this litle marvel submits all inputs to the goto service
			return `
<script>
	String.prototype.tag = ${"".tag}
	function submitForm() {
		var parms = {};
		[${keys}].forEach( (key) => parms[key] = document.getElementById("parms."+key).value );

		window.open( "/${goto}".tag("?", parms) );
	}
</script>
<form onsubmit="submitForm()">
	${inputs.join("")}
	<button id="parms.submit" type="submit" value="submit">submit</button>
</form>` ;

		}) );
	},
	
	function XFetch( cb ) {  // expand <!---fetch URL--->
		var 
			key = "@fetch",
			fetch = function ( rec, cb ) {  // callsback cb with expanded fetch-tag 
				//Log(">>>>Xfetch", rec.arg1);
				Fetch( rec.arg1, cb );
			},
			pattern = /<!---fetch ([^>]*)?--->/g;
			
		this.serialize( fetch, pattern, key, html => cb(html) );
	},

	function Xsection( cb ) { // expand #.... SECTION
		var
			key = "@sec",
			fetch = function (rec, cb) {
				//Log(">>>header", rec.ID, rec.arg0, rec.arg1, rec.arg2 );
				cb( rec.arg2.tag( "h"+rec.arg1.length, {} ) );
			},
			pattern = /^(\#+) (.*)\n/gm;
		
		//Log("Xsection", this.match( pattern ) );
		this.serialize( fetch, pattern, key, html => cb(html) );
	}
	
].Extend(String);

JAX.config({		// for blogging
	MathJax: {
		tex2jax: {
			//displayMath: [["$$","$$"]]
		}
	}
});

JAX.start();

Start("skin");

// UNCLASSIFIED
